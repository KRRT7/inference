name: Build Windows Installer

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      manual_version:
        description: 'Version to build (e.g., 1.0.0 or v1.0.0). Required for manual runs.'
        required: false # Set to false to allow an empty string check, but script will enforce it for manual runs

jobs:
  build_windows:
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # No 'path' means checkout to the root

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'


      - name: Determine Version
        id: determine_version
        shell: bash
        run: |
          VERSION=""
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            if [ -n "${{ inputs.manual_version }}" ]; then
              VERSION="${{ inputs.manual_version }}"
              VERSION=${VERSION#v}
              echo "Manual run detected. Using provided version: $VERSION"
            else
              echo "Error: For manual runs (workflow_dispatch), the 'manual_version' input is required."
              exit 1
            fi
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=$(echo "${{ github.ref }}" | sed 's!refs/tags/v!!')
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=$(echo "${{ github.ref }}" | sed 's!refs/tags/!!')
          fi

          if [ -z "$VERSION" ]; then
            echo "Error: Could not determine installer version."
            echo "  github.event_name: ${{ github.event_name }}"
            echo "  github.ref: ${{ github.ref }}"
            echo "  inputs.manual_version: ${{ inputs.manual_version }}"
            exit 1
          fi
          echo "installer_version_out=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Installer version set to: $VERSION"


      - name: Install Inno Setup
        shell: pwsh
        run: |
          $installerUrl = "https://jrsoftware.org/download.php/is.exe"
          $installerPath = "${{ runner.temp }}\isetup.exe"
          echo "Downloading Inno Setup from $installerUrl..."
          Invoke-WebRequest -Uri $installerUrl -OutFile $installerPath
          if (-not $?) { Write-Error "Failed to download Inno Setup installer"; exit 1 }
          echo "Installing Inno Setup..."
          Start-Process -FilePath $installerPath -ArgumentList "/VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-" -Wait
          if (-not $?) { Write-Error "Failed to install Inno Setup"; exit 1 }
          $innoPath = "C:\Program Files (x86)\Inno Setup 6"
          echo "Adding Inno Setup directory to PATH: $innoPath"
          Add-Content -Path $env:GITHUB_PATH -Value $innoPath
          # Verify ISCC.exe exists
          if (-not (Test-Path (Join-Path $innoPath "ISCC.exe"))) {
            Write-Error "ISCC.exe not found at $innoPath after installation."
            exit 1
          }
          echo "Inno Setup installed and added to PATH."


      - name: Install DigiCert Client tools
        id: install_digicert_tools # Renamed for clarity
        uses: digicert/ssm-code-signing@v1.0.0


      - name: Set DigiCert certificate
        shell: bash
        run: |
          if [ -z "${{ secrets.SM_CLIENT_CERT_FILE_B64 }}" ]; then
            echo "Error: SM_CLIENT_CERT_FILE_B64 secret is not set."
            exit 1
          fi
          # Ensure the D drive directory exists or create it if not
          # This is usually available on Windows runners, but good to be safe.
          # However, direct creation like this might be problematic if D: isn't guaranteed.
          # The action creates /d/ which on Windows often means a temp drive.
          # Let's stick to a path the DigiCert action might expect or a runner temp path.
          # The DigiCert docs for GH Actions specify /d/Certificate_pkcs12.p12. On Windows, this might translate to a specific temp path.
          # Let's try to use a known writable path like runner.temp
          CERT_PATH="${{ runner.temp }}\\Certificate_pkcs12.p12"
          echo "Decoding certificate to $CERT_PATH"
          echo "${{ secrets.SM_CLIENT_CERT_FILE_B64 }}" | base64 --decode > "$CERT_PATH"
          if [ ! -f "$CERT_PATH" ]; then
            echo "Error: Failed to create certificate file at $CERT_PATH"
            exit 1
          fi
          echo "SM_CLIENT_CERT_FILE_PATH=$CERT_PATH" >> $GITHUB_ENV

      - name: Set DigiCert environment variables
        id: set_digicert_config_vars # Renamed for clarity, id might not be strictly needed anymore unless other steps reference it
        shell: bash
        run: |
          if [ -z "${{ secrets.SM_HOST }}" ] || \
             [ -z "${{ secrets.SM_API_KEY }}" ] || \
             [ -z "${{ secrets.SM_CLIENT_CERT_PASSWORD }}" ] || \
             [ -z "${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }}" ]; then
            echo "Error: One or more DigiCert secrets (SM_HOST, SM_API_KEY, SM_CLIENT_CERT_PASSWORD, SM_CODE_SIGNING_CERT_SHA1_HASH) are not set."
            exit 1
          fi
          echo "SM_HOST=${{ secrets.SM_HOST }}" >> "$GITHUB_ENV"
          echo "SM_API_KEY=${{ secrets.SM_API_KEY }}" >> "$GITHUB_ENV"
          echo "SM_CLIENT_CERT_FILE=${{ env.SM_CLIENT_CERT_FILE_PATH }}" >> "$GITHUB_ENV" # This comes from 'Set up DigiCert certificate' step
          echo "SM_CLIENT_CERT_PASSWORD=${{ secrets.SM_CLIENT_CERT_PASSWORD }}" >> "$GITHUB_ENV"
          # VERSION logic is now removed from this step

          - name: Install inference_gpu and dependencies from local wheels
          shell: bash # Using bash for wildcard expansion in pip install
          run: |
            WHEEL_FILE=$(ls dist/inference_gpu-*.whl)
            echo "Found GPU wheel: $WHEEL_FILE"
            pip install --find-links=./dist/ "$WHEEL_FILE[sam,transformers,clip,http,yolo-world,gaze,grounding-dino]"
            echo "--- Installed inference_gpu details ---"
            pip show inference-gpu
            
      - name: Build local inference wheels
        shell: bash # Ensures 'make' and 'rm -rf' work as expected
        run: make create_wheels

      - name: Install PyInstaller and other build dependencies
        working-directory: ./app_bundles/windows # Adjusted path
        run: |
          pip install --upgrade pip
          pip install --upgrade pyinstaller pyinstaller-hooks-contrib
          pip install -r requirements.txt # This now only installs pyinstaller
          echo "DEBUG: PyInstaller version:"
          pip show pyinstaller
          echo "DEBUG: pyinstaller-hooks-contrib version:"
          pip show pyinstaller-hooks-contrib
  
      - name: Build Windows installer
        working-directory: ./app_bundles/windows
        env:
          BUILD_VERSION: ${{ steps.determine_version.outputs.installer_version_out }} # Use output from new Determine Version step
        run: python build.py


      - name: Sign Windows Installer with DigiCert
        shell: cmd
        env:
          INSTALLER_VERSION_FROM_STEP: ${{ steps.determine_version.outputs.installer_version_out }} # Use output from new Determine Version step
        run: |
          echo "Starting installer signing process..."
          set PKCS11_CONFIG_PATH=%USERPROFILE%\AppData\Local\Temp\smtools-windows-x64\pkcs11properties.cfg
          echo "PKCS11 Config Path: %PKCS11_CONFIG_PATH%"

          set INSTALLER_BASE_PATH=app_bundles\windows\installer
          set INSTALLER_VERSION=%INSTALLER_VERSION_FROM_STEP% # Use the env var
          REM The build.py script creates the installer in installer/inference-{version}-installer.exe
          set INSTALLER_FILENAME=inference-%INSTALLER_VERSION%-installer.exe
          set UNSIGNED_INSTALLER_PATH=%INSTALLER_BASE_PATH%\%INSTALLER_FILENAME%

          echo "Looking for installer at: %UNSIGNED_INSTALLER_PATH%"
          if not exist "%UNSIGNED_INSTALLER_PATH%" (
            echo "Error: Unsigned installer not found at %UNSIGNED_INSTALLER_PATH%"
            echo "Listing contents of %INSTALLER_BASE_PATH%:"
            dir "%INSTALLER_BASE_PATH%"
            exit /b 1
          )

          echo "Looking for PKCS11 config at: %PKCS11_CONFIG_PATH%"
          if not exist "%PKCS11_CONFIG_PATH%" (
            echo "Error: DigiCert PKCS11 config file not found at %PKCS11_CONFIG_PATH%"
            echo "Please ensure the 'Install DigiCert Client tools' step ran successfully and created this file."
            echo "Listing contents of %USERPROFILE%\AppData\Local\Temp\smtools-windows-x64\:"
            dir "%USERPROFILE%\AppData\Local\Temp\smtools-windows-x64\"
            exit /b 1
          )
          
          echo "Attempting to sign: %UNSIGNED_INSTALLER_PATH%"
          smctl sign --fingerprint ${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }} --input "%UNSIGNED_INSTALLER_PATH%" --config-file "%PKCS11_CONFIG_PATH%"
          if %ERRORLEVEL% neq 0 (
            echo "Error: smctl sign command failed with error code %ERRORLEVEL%"
            exit /b 1
          )
          echo "Installer signed successfully."

      - name: Upload Windows Installer
        uses: actions/upload-artifact@v4
        with:
          name: Roboflow-Inference-Windows-Installer
          # The build.py script creates the installer in installer/inference-{version}-installer.exe
          # We'll upload the whole installer directory, or use a wildcard if preferred.
          path: app_bundles/windows/installer/ # Adjusted path
          if-no-files-found: error # Fail the step if the installer directory is not found or empty

      - name: Upload Installer to Release
        if: github.event_name == 'release'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: ./app_bundles/windows/installer/inference-${{ steps.determine_version.outputs.installer_version_out }}-installer.exe
          asset_name: inference-${{ steps.determine_version.outputs.installer_version_out }}-installer.exe
          asset_content_type: application/vnd.microsoft.portable-executable 